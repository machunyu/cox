//********************************************************************************
//
//! \defgroup Stellaris_DMA Stellaris DMA
//!
//! \brief Stellaris DMA Peripheral Driver
//!
//! The CoX Peripheral Library also provides DMAs for function full functions of
//! Nuvoton Stellaris DMA. This module supports the whole LM3Sxx Series.
//!
//! <br /> 
//! <h1>Contents</h1>
//! - \ref Stellaris_DMA_Block
//! - \ref Stellaris_DMA_Function_Desc
//! - \ref Stellaris_DMA_API_Group
//!   - \ref Stellaris_API_Group_Configure_Control
//!   - \ref Stellaris_API_Group_Interrupt_Control
//!   - \ref Stellaris_API_Group_Trig_Control
//!   .
//! - \ref Stellaris_DMA_Usage
//! .
//!
//! <br />
//! \section Stellaris_DMA_Block 1. DMA Physical Block
//! <img src="Stellaris_DMA_block.png" />
//!
//! <br />
//! \section Stellaris_DMA_Function_Desc 2. Functional Description
//! The system control block has the following functions:
//! - The DMA has different configure parameter of transfer including width of data,
//!   the mode of address, and the mode of transfer, you must set them before you trig. 
//! - Each DMA channel can generates an individual interrupt when data transfer is    
//!   finished or  target abort interrupt generation during DMA transfer and the
//!   respective interrupt event flag IF will be set. The interrupt event flag will
//!   generates an interrupt to CPU if the interrupt enable bit IE.
//! - The DMA should be triged if you want to use it after you finish configuring. 
//! .
//!
//! <br />
//! \subsection Stellaris_DMA_API_Group 3. API Groups
//!
//! The DMA API is broken into three groups of functions:
//! - those that deal with DMA configure,
//! - those that deal with DMA interrupt control,
//! - those that deal with DMA transfer and trig control.
//! .
//! <br />
//! \subsection Stellaris_API_Group_Configure_Control 3.1 DMA configure control APIs
//!
//! The PDMA configure control are dealt with:
//! - uDMAEnable()
//! - uDMADisable()
//! - uDMAChannelEnable()
//! - uDMAChannelDisable()
//! - xDMAChannelDynamicAssign()
//! - xDMAChannelDeAssign()
//! - uDMAControlBaseSet()
//! - uDMAControlBaseGet()
//! - uDMAChannelControlSet()
//! - uDMAChannelAttributeEnable()
//! - uDMAChannelAttributeDisable()
//! - xDMAChannelAttributeSet()
//! - xDMAChannelAttributeGet()
//! - uDMAChannelSelectDefault()
//! - uDMAChannelSelectSecondary()
//! .
//!
//! <br />
//! \subsection Stellaris_API_Group_Interrupt_Control 3.2 DMA Interrupt Control APIs
//! - xDMAChannelIntCallbackInit()
//! - xDMAChannelIntCallbackGet()
//! - uDMAErrorStatusClear()
//! - uDMAErrorStatusGet()
//! .
//!
//! <br />
//! \subsection Stellaris_API_Group_Trig_Control 3.3 DMA Transfer and Trig Control
//!
//! - uDMAChannelTransferSet()
//! - uDMAChannelRequest()
//! - uDMAChannelScatterGatherSet()
//! - uDMAChannelSizeGet()
//! - uDMAChannelModeGet()
//! - PDMASharedBufferDataGet()
//! .
//! <br />
//! \section Stellaris_DMA_Usage 4.  Program Examples
//! The following example shows how to use the DMA API to configure DMA and implement
//! the function of transfer between memory and memory.
//! \code
//! #include "xhw_types.h"
//! #include "xhw_memmap.h"
//! #include "Xsysctl.h"
//! #include "Xhw_sysctl.h"
//! #include "test.h"
//! #include "xhw_dma.h"
//! #include "xdma.h"
//! #include "pdmamtom.h"
//! unsigned long ulSrcArray[64] = {0x01020304, 0x05060708, 0x090A0B0C, 0x0D0E0F10,
//!                                 0x11121314, 0x15161718, 0x191A1B1C, 0x1D1E1F20,
//!                                 0x21222324, 0x25262728, 0x292A2B2C, 0x2D2E2F30,
//!                                 0x31323334, 0x35363738, 0x393A3B3C, 0x3D3E3F40,
//!                                 0x41424344, 0x45464748, 0x494A4B4C, 0x4D4E4F50,
//!                                 0x51525354, 0x55565758, 0x595A5B5C, 0x5D5E5F60,
//!                                 0x61626364, 0x65666768, 0x696A6B6C, 0x6D6E6F70,
//!                                 0x71727374, 0x75767778, 0x797A7B7C, 0x7D7E7F80};
//! unsigned char IntMessage[] = "The DMA transfer over!";
//! unsigned long ulDestArray[64];
//! unsigned long i;
//! unsigned long ulAssignChannel;
//! unsigned char ucDMAControlTable[1024] __at(0x20001c00);
//! unsigned long TransferOver(void *pvCBData, 
//!                                       unsigned long ulEvent,
//!                                       unsigned long ulMsgParam,
//!                                       void *pvMsgData)
//! {
//!    for(i=0;i<25;i++)
//!    {
//!        TestIOPut(IntMessage[i]);
//!	TestIOPut('\n');
//!        TestIOPut('\r');
//!    }
//!    return 0;
//! }
//!//*****************************************************************************
//!
//!//Prints a decimal unsigned number.
//!
//!//param n is the number to be printed
//!
//!// Prints a decimal unsigned number.
//!
//!//return None.
//!
//!//*****************************************************************************
//! static 
//! void PrintN(unsigned long n)
//! {
//!    char buf[16], *p;
//!
//!    if (n == 0)
//!    {
//!        TestIOPut('0');
//!    }
//!    else
//!    {
//!        p = buf;
//!        while (n != 0)
//!        {
//!            *p++ = (n % 10) + '0';
//!            n /= 10;
//!        }
//!
//!        while (p > buf)
//!            TestIOPut(*--p);
//1    }
//! }
//!//*****************************************************************************
//!
//!// Ininite the UART case which is needed
//!
//!//param None
//!
//!// This function ininite the UART including clock source and enable UART
//!
//!//return none
//!
//! //*****************************************************************************
//! void UARTInit(void)
//! {
//!    //
//!    // Set SysClk 50MHz using Extern 12M oscillator
//!    //
//!    xSysCtlClockSet(50000000, xSYSCTL_OSC_MAIN|xSYSCTL_XTAL_16MHZ|SYSCTL_USE_OSC);
//!	   SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
//!   
//!    xSPinTypeUART(UART0RX, PA0);
//!    xSPinTypeUART(UART0TX, PA1);
//! 
//!    xSysCtlPeripheralReset(xSYSCTL_PERIPH_UART0);
//!    xSysCtlPeripheralEnable(xSYSCTL_PERIPH_UART0);                    
//!   
//!    UARTConfigSetExpClk(UART0_BASE, 115200, (UART_CONFIG_WLEN_8     | 
//!                                             UART_CONFIG_STOP_1     | 
//!                                             UART_CONFIG_PAR_NONE));
//! UARTEnable(UART0_BASE, (UART_BLOCK_UART | UART_BLOCK_TX | UART_BLOCK_RX));
//!
//!}
//!//*****************************************************************************
//!
//!// Ininite the uDMA case which is needed
//!
//!//param None
//!
//!// This function ininite the uDMA including clock source and enable uDMA 
//!
//!//return none
//!
//! //*****************************************************************************
//! void uDMAInit(void)
//! {
//!    unsigned long ulTemp;
//!    //
//!    // Enable Peripheral uDMA
//!    //
//!    SysCtlPeripheralEnable(SYSCTL_PERIPH_UDMA);
//!    uDMAControlBaseSet(ucDMAControlTable);
//!    ulTemp = xDMAChannelDynamicAssign(xDMA_REQUEST_MEM, xDMA_REQUEST_MEM);
//!    ulAssignChannel = ulTemp;
//!    uDMAChannelEnable(ulAssignChannel);
//!    //
//!    // Enable uDMA interrupt
//!    //
//!    xIntEnable(INT_UDMA);
//!    xIntPrioritySet(INT_UDMA, 1);
//!    uDMAEnable();
//! 
//!    xDMAChannelIntCallbackInit(ulAssignChannel, TransferOver);
//! }
//!//*****************************************************************************
//!
//!// PDMA Configure and Trig transfer
//!
//!//param None
//!
//!// This function configure PDMA and Trig transfer
//!
//!//return None
//!
//!//*****************************************************************************
//! void PDMAConfigAndTrigTransfer(void)
//! {
//!    unsigned long i;
//!    //
//!    // Enable DMA Channel 0
//!    //
//!    uDMAEnable(ulAssignChannel);
//!    //
//!    // Set Channel control  parameter
//!    //
//!    PDMAChannelControlSet(ulAssignChannel | UDMA_PRI_SELECT, UDMA_SIZE_32 |                    
//!                                                             UDMA_SRC_INC_32 |                  
//!                                                             UDMA_DST_INC_32);
//!    //
//!    // Trig DMA Transfer
//!    //
//!    uDMAChannelTransferSet(ulAssignChannel, ulSrcArray, ulDestArray ,128);
//!    
//!    uDMAChannelRequest(UDMA_CHANNEL_SW);
//!    for(i = 0;i < 64;i++)
//!    {
//!        PrintN(ulDestArray[i]);
//!        TestIOPut('\n');
//!        TestIOPut('\r');
//!	       SysCtlDelay(5000000);
//!    }
//! }
//!//*****************************************************************************
//!
//!//main function
//!
//!//param None
//!
//!//return None
//!//*****************************************************************************
//! int main(void)
//! {
//!    UARTInit();
//!    PDMAInit();
//!    while(1)
//!    {
//!        PDMAConfigAndTrigTransfer();
//!    }
//! }
//! \endcode
//! \note 
//!
//**********************************************************************************
